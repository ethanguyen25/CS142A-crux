//CruxParser.class
//ctx.declarationList()   will return a list of declarations
//   then look at each declaration list one by one
//from the programContext, envoke the visit methods on each of the declarations.


package crux.frontend;

import crux.frontend.ast.*;
import crux.frontend.ast.OpExpr.Operation;
import crux.frontend.pt.CruxBaseVisitor;
import crux.frontend.pt.CruxParser;
import crux.frontend.types.*;
import org.antlr.v4.runtime.ParserRuleContext;

import java.io.PrintStream;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * This class will convert the parse tree generated by ANTLR to AST It follows the visitor pattern
 * where declarations will be by DeclarationVisitor Class Statements will be resolved by
 * StatementVisitor Class Expressions will be resolved by ExpressionVisitor Class
 */

public final class ParseTreeLower {
  private final DeclarationVisitor declarationVisitor = new DeclarationVisitor();
  private final StatementVisitor statementVisitor = new StatementVisitor();
  private final ExpressionVisitor expressionVisitor = new ExpressionVisitor(true);
  private final ExpressionVisitor locationVisitor = new ExpressionVisitor(false);

  private final SymbolTable symTab;

  public ParseTreeLower(PrintStream err) {
    symTab = new SymbolTable(err);
  }

  private static Position makePosition(ParserRuleContext ctx) {
    var start = ctx.start;
    return new Position(start.getLine());
  }

  /**
   *
   * @return True if any errors
   */

  public boolean hasEncounteredError() {
    return symTab.hasEncounteredError();
  }

  /**
   * Lower top-level parse tree to AST
   * 
   * @return a {@link DeclarationList} object representing the top-level AST.
   */

  public DeclarationList lower(CruxParser.ProgramContext program) {
    Position pos = makePosition(program);
    List<Declaration> decList = new ArrayList<>();
    for (var decContext : program.declarationList().declaration()) {
      decList.add(decContext.accept(declarationVisitor));
    }
    return new DeclarationList(pos,decList);
  }

  /**
   * Lower statement list by lower individual statement into AST.
   * 
   * @return a {@link StatementList} AST object.
   */

    private StatementList lower(CruxParser.StatementListContext statementList) {
      Position pos = makePosition(statementList);
      List<Statement> sList = new ArrayList<>();
      for (var e : statementList.statement()) {
        sList.add(e.accept(statementVisitor));
      }
      return new StatementList(pos, sList);
    }


  /**
   * Similar to {@link #lower(CruxParser.StatementListContext)}, but handling symbol table as well.
   * 
   * @return a {@link StatementList} AST object.
   */

    private StatementList lower(CruxParser.StatementBlockContext statementBlock) {
      symTab.enter();
      StatementList sList = lower(statementBlock.statementList());
      symTab.exit();
      return sList;
    }



  /**
   * A parse tree visitor to create AST nodes derived from {@link Declaration}
   */

  private final class DeclarationVisitor extends CruxBaseVisitor<Declaration> {
    /**
     * Visit a parse tree variable declaration and create an AST {@link VariableDeclaration}
     * 
     * @return an AST {@link VariableDeclaration}
     */

      @Override public VariableDeclaration visitVariableDeclaration(CruxParser.VariableDeclarationContext ctx) {
        Position pos = makePosition(ctx);

        return new VariableDeclaration(pos, )
      }



    /**
     * Visit a parse tree array declaration and create an AST {@link ArrayDeclaration}
     * 
     * @return an AST {@link ArrayDeclaration}
     */

    /*
     * @Override public Declaration visitArrayDeclaration(CruxParser.ArrayDeclarationContext ctx) {
     * }
     */


    /**
     * Visit a parse tree function definition and create an AST {@link FunctionDefinition}
     * 
     * @return an AST {@link FunctionDefinition}
     */
    /*
     * @Override public Declaration visitFunctionDefinition(CruxParser.FunctionDefinitionContext
     * ctx) { }
     */
  }

  /**
   * A parse tree visitor to create AST nodes derived from {@link Statement}
   */

  private final class StatementVisitor extends CruxBaseVisitor<Statement> {
    /**
     * Visit a parse tree variable declaration and create an AST {@link VariableDeclaration}. Since
     * {@link VariableDeclaration} is both {@link Declaration} and {@link Statement}, we simply
     * delegate this to
     * {@link DeclarationVisitor#visitArrayDeclaration(CruxParser.ArrayDeclarationContext)} which we
     * implement earlier.
     * 
     * @return an AST {@link VariableDeclaration}
     */

    /*
     * @Override public Statement visitVariableDeclaration(CruxParser.VariableDeclarationContext
     * ctx) { return declarationVisitor.visitVariableDeclaration(ctx); }
     */


    /**
     * Visit a parse tree assignment statement and create an AST {@link Assignment}
     * 
     * @return an AST {@link Assignment}
     */

    /*
     * @Override public Statement visitAssignmentStatement(CruxParser.AssignmentStatementContext
     * ctx) { }
     */

    /**
     * Visit a parse tree call statement and create an AST {@link Call}. Since {@link Call} is both
     * {@link Expression} and {@link Statement}, we simply delegate this to
     * {@link ExpressionVisitor#visitCallExpression(CruxParser.CallExpressionContext)} that we will
     * implement later.
     * 
     * @return an AST {@link Call}
     */
    /*
     * @Override public Statement visitCallStatement(CruxParser.CallStatementContext ctx) { }
     */

    /**
     * Visit a parse tree if-else branch and create an AST {@link IfElseBranch}. The template code
     * shows partial implementations that visit the then block and else block recursively before
     * using those returned AST nodes to construct {@link IfElseBranch} object.
     * 
     * @return an AST {@link IfElseBranch}
     */

    /*
     * @Override public Statement visitIfStatement(CruxParser.IfStatementContext ctx) { }
     */

    /**
     * Visit a parse tree while loop and create an AST {@link Loop}. You'll going to use a similar
     * techniques as {@link #visitIfStatement(CruxParser.IfStatementContext)} to decompose this
     * construction.
     * 
     * @return an AST {@link Loop}
     */

    /*
     * @Override public Statement visitLoopStatement(CruxParser.LoopStatementContext ctx) { }
     */


    /**
     * Visit a parse tree return statement and create an AST {@link Return}. Here we show a simple
     * example of how to lower a simple parse tree construction.
     * 
     * @return an AST {@link Return}
     */

    /*
     * @Override public Statement visitReturnStatement(CruxParser.ReturnStatementContext ctx) { }
     */

    /**
     * Creates a Break node
     */

    /*
     * @Override public Statement visitBreakStatement(CruxParser.BreakStatementContext ctx) { }
     */

    /**
     * Creates a Continue node
     */

    /*
     * @Override public Statement visitContinueStatement(CruxParser.ContinueStatementContext ctx) {
     * }
     */
  }

  private final class ExpressionVisitor extends CruxBaseVisitor<Expression> {
    // Flag to enable dereferencing
    private final boolean dereferenceDesignator;

    private ExpressionVisitor(boolean dereferenceDesignator) {
      this.dereferenceDesignator = dereferenceDesignator;
    }

    /**
     * Parse Expression0 to OpExpr Node Parsing the expression should be exactly as described in the
     * grammer
     */

    /*
     * @Override public Expression visitExpression0(CruxParser.Expression0Context ctx) { }
     */

    /**
     * Parse Expression1 to OpExpr Node Parsing the expression should be exactly as described in the
     * grammer
     */

    /*
     * @Override public Expression visitExpression1(CruxParser.Expression1Context ctx) { }
     */

    /**
     * Parse Expression2 to OpExpr Node Parsing the expression should be exactly as described in the
     * grammer
     */

    /*
     * @Override public Expression visitExpression2(CruxParser.Expression2Context ctx) { }
     */

    /**
     * Parse Expression3 to OpExpr Node Parsing the expression should be exactly as described in the
     * grammer
     */

    /*
     * @Override public Expression visitExpression3(CruxParser.Expression3Context ctx) { }
     */

    /**
     * Create an Call Node
     */

    /*
     * @Override public Call visitCallExpression(CruxParser.CallExpressionContext ctx) { }
     */

    /**
     * visitDesignator will check for a name or ArrayAccess FYI it should account for the case when
     * the designator was dereferenced
     */

    /*
     * @Override public Expression visitDesignator(CruxParser.DesignatorContext ctx) { }
     */

    /**
     * Create an Literal Node
     */

    /*
     * @Override public Expression visitLiteral(CruxParser.LiteralContext ctx) { }
     */
  }
}
